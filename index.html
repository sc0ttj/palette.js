<html !doctype=html5>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<style>
/* style body */
body { font-size: 16px; padding: 32px; background-color: #EFEFEF; transition: background-color 0.25s, color 0.25s; max-width: 960px; margin: 0 auto; position: relative; }
/* dark mode for whole page */
body.dark { background-color: #2d2d2d; color: #efefef; }
/* palette titles */
h3 { margin-top: 2rem; margin-bottom: 0.8rem; }
h3:first-letter { text-transform: uppercase; }
/* style links to work in dark & light mode */
a { font-weight: bold; color: rgb(0 198 255 / 1); }
a:visited { color: rgb(0 198 255 / 1); }
/* alignment stuff */
* { box-sizing: border-box; }
/* color boxes container, default styles */
.palette { margin-top: -1px; }
/* color boxes, default styles */
.color { margin-top: -1px; margin-left: -1px; border: 1px solid #2d2d2d;  border-color: transparent; transition: border-radius 0.25s ease-out, border-color 0.5s; }
/* style mods for color boxes */
.with-borders { border-color: #2d2d2d; }
.with-borders:first-of-type { border-left: 1px solid #222; }
.with-rounded { border-radius: 50%; }
.with-spacing { margin-left: 2px; margin-right: 2px; margin-top: 4px; }
.with-greyscale { filter: saturate(0); background-color: lch(none 0 none); }
/* UI buttons on top right corner of page, for toggling style mods */
.ui-settings { position: fixed; top: 0px; left: 48%; padding: 8px; text-align: right; min-width: 200px; line-height: 1.6rem; }
.ui-settings a { display: block; }
.ui-settings p { margin: 0; }
.ui-settings .light-switch a { display: inline-block; }

.color-chooser { border: 1px solid transparent; padding: 0.5rem; margin: 1rem 0; border-left: 110px; margin-left: -110px; position: relative; }
.color-chooser td { padding: 2px; width: 56px; text-align: center; }
.color-chooser input {
  max-width: 65px;
  text-align: center;
  padding: 8px 4px;
}
.color-chooser tr:nth-child(3) td { font-size: 0.75rem; }

/* not used */
canvas { border: 1px solid #222; display: none; }
</style>
<body>
<h1>Palette.js</h1>
<div class="ui-settings">
  <div class="color-chooser">
    <table>
      <tr>
        <td>L</td>
        <td>C</td>
        <td>H</td>
        <td>A</td>
      </tr>
      <tr>
        <td><input class="l" type="number" min="0" max="100" /></td>
        <td><input class="c" type="number" min="0" max="150" /></td>
        <td><input class="h" type="number" min="0" max="360" /></td>
        <td><input class="a" type="number" min="0" max="1" /></td>
      </tr>
      <tr>
        <td>0-100</td>
        <td>0-150</td>
        <td>0-360</td>
        <td>0-1</td>
      </tr>
    </table>
  </div>
  <p>Toggle:</p>
  <div class="light-switch">
    <a class="light" href="">Light</a> / <a class="dark" href="">Dark</a>
  </div>
  <a class="borders" href="#">Disable Borders</a>
  <a class="rounded" href="#">Enable Rounded</a>
  <a class="spacing" href="#">Enable Spacing</a>
  <a class="greyscale" href="#">Enable Greyscale</a>
</div>
<canvas></canvas>
<script>

let palettes; //global var to store our palettes


// toggle light mode
[ 'dark', 'light' ].forEach(setting => {
  const body = document.querySelector('body');
  document.querySelector(`.light-switch .${setting}`).addEventListener('click', e => {
    if (setting === 'light') body.classList.remove('dark');
    if (setting === 'dark') body.classList.add('dark');
    e.preventDefault();
    return false;
  });
});
// toggle UI settings
[ 'borders', 'rounded', 'spacing', 'greyscale' ].forEach(setting => {
  const btn = document.querySelector(`.${setting}`);
  btn.addEventListener('click', e => {
    const elems = document.querySelectorAll('.color');
    const action = !logOpts[setting] ? 'add' : 'remove';
    elems.forEach((el, i) => el.classList[action](`with-${setting}`));
    e.target.innerHTML = `${action !== 'add' ? 'Enable' : 'Disable'} ${setting}`;
    logOpts[setting] = !logOpts[setting];
    e.preventDefault();
    return false;
  });
});
// allow chosing a new base color
const inputs = {
  l: document.querySelector('input.l'),
  c: document.querySelector('input.c'),
  h: document.querySelector('input.h'),
  a: document.querySelector('input.a'),
};
Object.keys(inputs).forEach(el => {
  inputs[el].addEventListener('change', event => {
    const newColor = {
      l: Number(inputs.l.value),
      c: Number(inputs.c.value),
      h: Number(inputs.h.value),
      alpha: Number(inputs.a.value),
      mode: 'lch',
    };
    // Set some palette options
    const steps = 9;
    const opts = {
      hueShift: { hueStep:  12,   minLight: 15, maxLight: 100 },
      pixelArt: { hueStep: -22.5, minLight: 10, maxLight: 95, steps: 10 },
    };
    // Generate all palettes, from a single RGB or LCH (preferred) color
    palettes = new Palette(newColor, steps, opts);
    // update the page
    document.querySelectorAll('.palette').forEach(el => el.remove());
    render(palettes);
  });
});


// defines a Palette function, which:
//
// - generate palettes from a single base color:
//    - uses LCH color wheel internally to find the palette colours
//      - "scientific" palettes:
//        - https://tympanus.net/codrops/2021/12/07/coloring-with-code-a-programmatic-approach-to-design/
//        - triadic
//        - complementary
//        - split complementary
//        - tetradic
//        - analagous
//        - rainbow
//        - ...and more
//      - "dataviz" palettes (steps) and scales (gradients):
//        - sequential
//        - categorical (various kinds)
//        - divergent
//      - "hue shift" palettes:
//        - https://tympanus.net/codrops/2021/12/07/coloring-with-code-a-programmatic-approach-to-design/
//        - https://codepen.io/georgedoescode/pen/gOGaOwm
//        - base color in middle, make a scale - to lighter on left, darker on right
//        - as color gets lighter, shift hue up
//        - as color gets darker, shift hue down
//      - color tones (uses LCH internally):
//        - decreasing saturation (to grey)
//      - tints and shades (use RGB internally):
//        - tints add lightness (white)
//        - shades add darkness (black)
//        - monochromatic scale (adapted version of shades and tints combined)
//        - light and dark (highlight/shadow, or fg/bg)
//      - perceptually equidistant gradients (use LAB internally)
// - outputs same color mode (color space) as received
// - conversion methods available:
//    - hex2lch
//    - hex2rgb
//    - lab2lch
//    - lch2hex
//    - lch2lab
//    - lch2rgb
//    - rgb2cmyk
//    - rgb2gl
//    - rgb2hex
//    - rgb2hsl
//    - rgb2hsv
//    - rgb2hwb
//    - rgb2lab
//    - rgb2lch
//    - rgb2xyz
//    - xyz2lab
// - supports/maintains/respects transparency
// - methods available to generate your own palettes, gradients and scales:
//    - scientific(color, steps)
//    - hueShift(color, opts)
//    - tints(color, steps)
//    - shades(color, steps)
//    - monochromatic(color, steps)
//    - tonal(color, steps)
//    - gradient(color1, color2, steps) @TODO support more than 2 colors
//    - toAlpha(color, steps)
//    - sequential(color, contrast, steps)
//    - categorical(color, contrast, hueOffset, steps)
//    - divergent(color1, color2, contrast, middlePoint, steps)
//    - random(color, amount steps) - see https://randomcolor.lllllllllllllllll.com/
// - @TODO methods added to each palette:
//    - myPalette.spin(deg)              // spin the hue of each color in the palette
//    - myPalette.sortBy(prop[, 'asc'])  // return palette colors ordered by the given color property (r,g,b,l,c,h,etc), asc or not
//    - myPalette.transpose()            // flip/invert the palettes rows & cols
// - @TODO methods added to each color, `amount` is always 0-1 :
//    - color.fixContrast(color2)     // fixes contrast/distance between two colors to meet WGAC2 accessibility standards
//    - color.mix(color, amount)      // mixes two colors by given amount (0 to 1)
//    - color.invert(amount)          // gives the "opposite" color
//    - color.randomise(amount)       // randomise lightness and chroma within the given % amount
//    - color.toAlpha(amount)         // returns adjusted `color`, with added amount of transparency
//    - color.toWhiteAlpha(amount)    // returns adjusted `color`, as it'd look if it were transparent by given amount, against a white background
//    - color.toBlackAlpha(amount)    // returns adjusted `color`, as it'd look if it were transparent by given amount, against a black background

/* @TODO - move logging functions into Palette

  - make it easy to log/print palettes using in-built functions like:

    triadic.log('boxes');  // log as a series of boxes
    triadic.log('scale');  // log as a continuous scale/gradient
    triadic.log('wheel');  // log as a cyclical gradient as a circle
    triadic.log('ring');   // log as a cyclical gradient as a doughnut/ring

*/
/* @TODO - make Palette smaller

  - move outside of Palette, as part of demo code:
    - all "picker" palettes
    - all "categorical" palettes except "complementary"
    - all "scale" palettes
    - "equidistant" and "wheel" palettes
  - generate them using the provided `palette.create` methods

  - don't support hsl, hsv, cymk, webgl,

*/

/*
 @TODO - convert this to JS !!!

  A super tiny but lovely palette generator ..uses Vectors

  https://iquilezles.org/articles/palettes/
*/


/*

@TODO also see https://github.com/mattgperry/vekta

*/

function Palette(base, steps = 8, opts = {}) {
/*
  // NOT USED YET
  const normalizeHue = hue => ((hue = hue % 360) < 0 ? hue + 360 : hue);

  // NOT USED YET
  const hueToDeg = (val, unit) => {
  	switch (unit) {
  		case 'deg':
  			return +val;
  		case 'rad':
  			return (val / Math.PI) * 180;
  		case 'grad':
  			return (val / 10) * 9;
  		case 'turn':
  			return val * 360;
  	}
  };

  // NOT USED YET  -  uses lch2lab() and getColorDistance()
	const diffSort = (colors) => {
		let diffColors = [colors.shift()];
		while(colors.length > 0) {
			var index = -1;
			var maxDistance = -1;
			for (let color_index = 0; color_index < colors.length; color_index++) {
				var d = Infinity;
				for (let i = 0; i < diffColors.length; i++) {
					var colorA = lch2lab(colors[color_index]);
					var colorB = lch2lab(diffColors[i]);
					var d = getColorDistance(colorA, colorB);
				}
				if (d > maxDistance) {
					maxDistance = d;
					index = color_index;
				}
			}
			var color = colors[index];
			diffColors.push(color);
			colors = colors.filter(function(c,i) {return i!=index;});
		}

		return diffColors;
	}

  // uses LAB
  const getColorDistance = euclidianDistance(lab1, lab2) => {
	  return Math.sqrt(Math.pow(lab1.l-lab2.l, 2) + Math.pow(lab1.a-lab2.a, 2) + Math.pow(lab1.b-lab2.b, 2));
	}

*/

  // utility methods
  this.utils = {
    spin: (deg) => {
      if (deg < 0) deg += Math.ceil(-deg / 360) * 360;
      return deg % 360;
    },

    /* mix two colors, uses LAB gradient */
    // `amount` is a number between 0.0 and 1.0, and is the amount of the second colour to mix in
    mix: (color1, color2, amount = 0.5) =>
      gradient(color1, color2, 100)[amount.toFixed(2)*100],

    /* Usage :  scale 50 out 0-100 to 50 out of 0-200
       rescale(50,  0,100,  0,200)  // gives 100
    */
    rescale: (n, start1, end1, start2, end2) =>
      ((n - start1) / (end1 - start1)) * (end2 - start2) + start2,

    /* Swap the rows and columns of a nested array, (a.k.a "2d array" or "matrix")
      transpose([   // returns:
        [1, 2, 3],  //  [1, 4, 7],
        [4, 5, 6],  //  [2, 5, 8],
        [7, 8, 9],  //  [3, 6, 9],
      ]);
    */
    transpose: (arr) =>
      arr[0].map((col, i) =>
        arr.map((row) => row[i])),

    // sort array of object by given key name and order ('asc'/'desc')
    sortBy: (arr, prop, order = 'asc') =>
      [...arr].sort((a, b) =>
        order === 'asc'
          ? a[prop] - b[prop]
          : b[prop] - a[prop]),
  };

  const {
    mix,
    rescale,
    sortBy,
    spin,
    transpose,
  } = this.utils;

  // converter functions

  const num2hex = (n) => {
    let hex = n.toString(16);
    return hex.length == 1 ? "0" + hex : hex;
  }

  this.convert = {

    lch2rgb: (color) => {
      const { l, c, h, mode, alpha } = color;
      if (mode === 'rgb') return color;

      const lab_xyz = (x) => (x > 0.206893034) ? x * x * x : (x - 4 / 29) / 7.787037,
    	      xyz_rgb = (r) => Math.round(255 * (r <= 0.00304 ? 12.92 * r : 1.055 * Math.pow(r, 1 / 2.4) - 0.055)),
    	      rgbCap  = (x) => Math.max(0, Math.min(255, x));

    	let rgb = [],
    	    // convert to Lab
    	    h1 = h * Math.PI / 180,
    	    a = Math.cos(h1) * c,
    	    b = Math.sin(h1) * c,
        	// convert to rgb
    	    X = 0.950470,
    	    Y = 1,
    	    Z = 1.088830,
    	    y = (l + 16) / 116,
    	    x = y + a / 500,
    	    z = y - b / 200;

    	x = lab_xyz(x) * X;
    	y = lab_xyz(y) * Y;
    	z = lab_xyz(z) * Z;

    	rgb[0] = rgbCap(xyz_rgb(3.2404542 * x - 1.5371385 * y - 0.4985314 * z));
    	rgb[1] = rgbCap(xyz_rgb(-0.9692660 * x + 1.8760108 * y + 0.0415560 * z));
    	rgb[2] = rgbCap(xyz_rgb(0.0556434 * x - 0.2040259 * y + 1.0572252 * z));

    	return {
        r: rgb[0],
        g: rgb[1],
        b: rgb[2],
        alpha: (alpha || alpha === 0) ? alpha : 1,
        mode: "rgb",
        css: `rgb(${rgb[0]} ${rgb[1]} ${rgb[2]}${(alpha || alpha === 0) ? ' / '+alpha : ''})`,
      };
    },

    // @TODO fix alpha handling
    hex2rgb: (color) => {
      let { value, mode, alpha } = color;
      if (mode === 'rgb') return color;

      const bigint = parseInt(color.css, 16),
            r = (bigint >> 16) & 255,
            g = (bigint >> 8) & 255,
            b = bigint & 255;
      return {
        r, g, b,
        alpha: 1,
        mode: "rgb",
        css: `rgb(${r} ${g} ${b} / 1)`,
      };
    },

    // @TODO fix alpha handling
    rgb2hex: (color) => {
      const { r, g, b, alpha, mode } = color;
      if (mode === 'hex') return color;
      return {
        mode: 'hex',
        r: num2hex(r),
        g: num2hex(g),
        b: num2hex(b),
        alpha,
        css: `#${num2hex(r) + num2hex(g) + num2hex(b)}`,
      }
    },

    hex2lch: hexColor => rgb2lch(hex2rgb(hexColor)),
    lch2hex: lchColor => rgb2hex(lch2rgb(lchColor)),

    rgb2xyz: (color) => {
      let { r, g, b, mode, alpha } = color;
      if (mode === 'xyz') return color;
      r = r / 255;
      g = g / 255;
      b = b / 255;
      let min = 0.04045,
          div = 12.92,
          o55 = 0.055,
          t4 = 2.4,
          oneo55 = 1.055;

    	r = 100 * ( (r > min) ? Math.pow( (r + o55) / oneo55, t4 ) : r / div );
	    g = 100 * ( (g > min) ? Math.pow( (g + o55) / oneo55, t4 ) : g / div );
	    b = 100 * ( (b > min) ? Math.pow( (b + o55) / oneo55, t4 ) : b / div );

      // Observer = 2°, Illuminant = D65
      const x = r * 0.4124 + g * 0.3576 + b * 0.1805,
            y = r * 0.2126 + g * 0.7152 + b * 0.0722,
            z = r * 0.0193 + g * 0.1192 + b * 0.9505;

      return {
        x, y, z,
        mode: 'xyz',
        alpha: (alpha || alpha === 0) ? alpha : 1,
        css: `xyz(${x} ${y} ${z}${(!!alpha || alpha === 0) ? ' / '+alpha : ''})`
      };
    },

    xyz2lab: (color) => {
      let { x, y, z, mode, alpha } = color;
      if (mode === 'lab') return color;
      // Observer = 2°, Illuminant = D65
      x /= 95.047;
      y /= 100.000;
      z /= 108.883;

      const third = 0.333333333,
          min = 0.008856,
          minAdjust = 0.137931034,
          sev = 7.787;

      x = (x > min) ? Math.pow(x, third) : sev * x + minAdjust;
      y = (y > min) ? Math.pow(y, third) : sev * y + minAdjust;
      z = (z > min) ? Math.pow(z, third) : sev * z + minAdjust;

      const l = (116 * y) - 16,
            a = 500 * (x - y),
            b = 200 * (y - z);

      return {
        l, a, b,
        mode: 'lab',
        alpha: (alpha || alpha === 0) ? alpha : 1,
        css: `lab(${l}% ${a} ${b}${(alpha || alpha === 0) ? ' / '+a : ''})`,
      };
    },

    lab2lch: (color) => {
      let { l, a, b, mode, alpha } = color;
      if (mode === 'lch') return color;

      const c = Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2))

      let h = Math.atan2(b, a) //Quadrant by signs
      if (h > 0) {
        h = (h / Math.PI) * 180
      } else {
        h = 360 - (Math.abs(h) / Math.PI) * 180
      }

      return {
        l, c, h,
        mode: 'lch',
        alpha: (alpha || alpha === 0) ? alpha : 1,
        css: `lch(${l}% ${c} ${h}deg${(alpha || alpha === 0) ? ' / '+a : ''})`,
      };
    },

    lch2lab: (color) => {
      const  { l, c, h, mode, alpha } = color;
      if (mode === 'lab') return color;
      const deg2rad = x => x * Math.PI / 180,
            sind = x => Math.sin(deg2rad(x)),
            cosd = x => Math.cos(deg2rad(x)),
          	// convert to Lab a and b from the polar form
    	      [ labA, labB ] = [
          		c * cosd(h),
          		c * sind(h),
          	];
      return {
        l,
        a: labA,
        b: labB,
        alpha: (alpha || alpha === 0) ? alpha : 1,
        mode: 'lab',
        css: `lab(${l}% ${labA} ${labB}${(alpha || alpha === 0) ? ' / '+alpha : ''})`,
      };
    },

    // RGB → XYZ → LAB → LCH
    rgb2lch: (color) => lab2lch(xyz2lab(rgb2xyz(color))),

/*
    // hwb is human friendlier hsv (supported by CSS, since CSS4)
    hwb2rgb: (hwbColor) => {
      const { h, w, b } = hwbColor;
      var rgb = hsl2rbg(h, 1, 0.5) // @TODO hsl2rbg()

      for (var i = 0; i < 3; ++i) {
        var c = rgb[i] / 255

        c *= 1 - w - b
        c += w

        rgb[i] = Math.round(c * 255)
      }

      return {
        r: rgb[0],
        g: rgb[1],
        b: rgb[2],
        mode: 'rgb',
        css: `rgb(${rgb[0]}, ${rgb[1]}, ${rgb[2]})`
      };
    },

*/

    rgb2hwb: (color) => {
      let { r, g, b, mode, alpha } = color;
      if (mode === 'hwb') return color;
      let h, w, bl;
      r = r / 255;
      g = g / 255;
      b = b / 255;
      max = Math.max(r, g, b);
      min = Math.min(r, g, b);
      chroma = max - min;
      if (chroma == 0) {
        h = 0;
      } else if (r == max) {
        h = (((g - b) / chroma) % 6) * 360;
      } else if (g == max) {
        h = ((((b - r) / chroma) + 2) % 6) * 360;
      } else {
        h = ((((r - g) / chroma) + 4) % 6) * 360;
      }
      w = min;
      bl = 1 - max;

      return {
        h,
        w,
        b : bl,
        mode: 'hwb',
        alpha: (alpha || alpha === 0) ? alpha : 1,
        css: `hwb(${h} ${w}% ${bl}%${(alpha || alpha === 0) ? ' / '+alpha : ''})`,
      };
    },

    rgb2hsl: (color) => {
    	let { r, g, b, mode, alpha } = color;
      if (mode === 'hsl') return color;
    	r = r / 255;
    	g = g / 255;
    	b = b / 255;
    	let h, s;

    	const min = Math.min(r, g, b),
    	      max = Math.max(r, g, b),
    	      delta = max - min;

    	if (max === min) {
    		h = 0;
    	} else if (r === max) {
    		h = (g - b) / delta;
    	} else if (g === max) {
    		h = 2 + (b - r) / delta;
    	} else if (b === max) {
    		h = 4 + (r - g) / delta;
    	}

    	h = Math.min(h * 60, 360);

    	if (h < 0) h += 360;

    	const l = (min + max) / 2;

    	if (max === min) {
    		s = 0;
    	} else if (l <= 0.5) {
    		s = delta / (max + min);
    	} else {
    		s = delta / (2 - max - min);
    	}

    	return {
    	  h,
    	  s: s * 100,
    	  l: l * 100,
    	  mode: 'hsl',
        alpha: (alpha || alpha === 0) ? alpha : 1,
    		css: `hsl(${h}deg ${s*100}% ${l*100}%${(alpha || alpha === 0) ? ' / '+alpha : ''})`
    	};
    },

    rgb2hsv: (color) => {
      let { r, g, b, mode, alpha } = color;
      if (mode === 'hsv') return color;

      let rdif,
    	    gdif,
    	    bdif,
    	    h,
    	    s;

    	r = r / 255;
    	g = g / 255;
    	b = b / 255;
    	const v = Math.max(r, g, b),
    	      diff = v - Math.min(r, g, b),
    	      diffc = (c) => (v - c) / 6 / diff + 1 / 2;

    	if (diff === 0) {
    		h = 0;
    		s = 0;
    	} else {
    		s = diff / v;
    		rdif = diffc(r);
    		gdif = diffc(g);
    		bdif = diffc(b);

    		if (r === v) {
    			h = bdif - gdif;
    		} else if (g === v) {
    			h = (1 / 3) + rdif - bdif;
    		} else if (b === v) {
    			h = (2 / 3) + gdif - rdif;
    		}

    		if (h < 0) {
    			h += 1;
    		} else if (h > 1) {
    			h -= 1;
    		}
    	}

    	return {
    		h: h * 360,
    		s: s * 100,
    		v: v * 100,
    		mode: 'hsv',
        alpha: (alpha || alpha === 0) ? alpha : 1,
    		css: `hsv(${h*360}deg ${s*100}% ${v*100}%${(alpha || alpha === 0) ? ' / '+alpha : ''})`
    	};
    },

    rgb2cmyk: (color) => {
      let { r, g, b, mode, alpha } = color;
      if (mode === 'cmyk') return color;
      let c = 1 - (r / 255),
          m = 1 - (g / 255),
          y = 1 - (b / 255),
          k = Math.min(c, m, y);

      c = (c - k) / (1 - k);
      m = (m - k) / (1 - k);
      y = (y - k) / (1 - k);

      return {
        c, m, y, k,
        mode: 'cmyk',
        alpha: (alpha || alpha === 0) ? alpha : 1,
        css: `cmyk(${c}% ${m}% ${y}% ${k}%${(alpha || alpha === 0) ? ' / '+alpha : ''})`,
      };
    },

    // @TODO for PIXI.js
    //rgb2pixi: ({ r, g, b, alpha }) => {
    //  return parseInt(rgb2hex({ r, g, b, alpha }), 16);
    //},

    // webGL expects [r,g,b,a]  all within in range 0 - 1
    rgb2gl: (color) => {
      let { r, g, b, mode, alpha } = color;
      if (mode === 'gl') return color;

      return {
        r: r / 255.0,
        g: g / 255.0,
        b: b / 255.0,
        a: (alpha || alpha === 0) ? alpha : 1
      };
    },

    // rgb2threejs uses 0xff9900 (not strings, no quotes)

  };

  const {
    hex2lch,
    hex2rgb,
    lab2lch,
    lch2hex,
    lch2lab,
    lch2rgb,
    rgb2cmyk,
    rgb2gl,
    rgb2hex,
    rgb2hsl,
    rgb2hsv,
    rgb2hwb,
    rgb2lab,
    rgb2lch,
    rgb2pixi,
    rgb2xyz,
    xyz2lab,
  } = this.convert;

  // palette functions

  this.create = {
    // "scientific" palettes
    // color is in lch format
    scientific: (color) => {
      const obj = {},
            { l, c, h, alpha, mode } = color,
            offset = 0-h,   // resets hue to zero
            ra = offset+40, // sets a "red" hue adjustment
            list = {
              // these are offset to always start at "red" hue (40)
              primary: [ ra, ra+96,  ra+250 ],
              primaryRYB: [ ra, ra+57.1, ra+250 ],
              rainbow: [ra, ra+32.7, ra+55, ra+80, ra+240, ra+290, ra-40 ],
              // these start at the given base color hue
              complementary: [0, 180],
              analogous: [0, 30, 60],
              analogousReverse: [0, -30, -60],
              analogousSplit: [-30, 0, 30],
              triadic: [0, 120, 240],
              tetradic: [0, 90, 180, 270],       // a.k.a "square"
              splitComplementary: [0, 150, 210], // a.k.a "compound"
              doubleComplementary: [-30, 30, 150, 210], // a.k.a split on both sides
              polychromatic: [0, 60, 120, 180, 240, 300], // every other color from circle of 12
              wheel: Array.from({ length: 360 },(_,i) => i),   // all degrees in a circle (0-359)
            };
      for (const type of Object.keys(list)) {
        this[type] = obj[type] = list[type].map((step) => ({
          l,
          c,
          h: spin(h + step),
          alpha,
          mode,
        }));
      }
      return obj;
    },

    // @TODO check/fix alpha calculations?
    // color1 is in lch format
    // color2 is in lch format
    gradient: (color1, color2, steps) => {
      const c1 = lch2lab(color1),
            c2 = lch2lab(color2),
            gradient = [];
      for (let i = 0.0; i <= steps; i++) {
        let v = i / (steps-1),  // 0.0 <= v <= 1.0
            l = (1-v) * c1.l + v * c2.l,
            a = (1-v) * c1.a + v * c2.a,
            b = (1-v) * c1.b + v * c2.b,
            alpha = (1-v) * c1.alpha + v * c2.alpha;
        gradient.push({ l, a, b, alpha, mode: 'lab' });
      }
      return gradient.map(color => lab2lch(color));
    },

    // colors is an array of objects, each obj is a color in lch format
    // midPoints is an array of points along the gradient (0.33 = 33%)
    gradients: (colors, steps) => {
      let arr = [];
      colors.forEach((color, i) => {
        const hasNext = !!colors[i+1];
        if (hasNext) {
          let a = gradient(colors[i], colors[i+1], steps[i]);
          a.pop();
          arr.push(a);
        }
      });
      return arr.flat();
    },

    // "hue shift" palettes
    // color is in lch format
    hueShift: (color, opts) => {
      const { minLight, maxLight, hueStep, steps } = opts,
            { l, c, h, mode, alpha } = color,
            palette = [color],
            total = steps/2;
      for (let i = 1; i <= total; i++) {
        const hueDark  = spin(h - hueStep * i),
              hueLight = spin(h + hueStep * i),
              darkness  = rescale(i,  0,total,  l,minLight),
              lightness = rescale(i,  0,total,  l,maxLight),
              chroma = c;

        palette.push({ // add to start of array
          l: darkness,
          c: chroma,
          h: hueDark,
          alpha,
          mode
        });
        palette.unshift({ // add to end of array
          l: lightness,
          c: chroma,
          h: hueLight,
          alpha,
          mode
        });
      }
      return palette;
    },

    // color is in lch format
    // amount should be a nunmber between 0 and 100
    randomised: (color, amount) => {
      const randomFloat = (min, max) => Math.random() * (max - min) + min,
            num = randomFloat(-36, 36) * (amount/100),
            randomBoolean = () => Math.random() >= 0.5,
            { l, c, h, mode, alpha } = color; // the values to randomise

      return {
        l: (randomBoolean() ? l+(num) : l-(num)),
        c: (randomBoolean() ? c+(num) : c-(num)),
        h: (randomBoolean() ? h+((num)/2) : h-((num)/2)),
        mode,
        alpha,
      };
    },

    hueGradient: steps => gradient(
      this.hueShift[0],
      this.hueShift[this.hueShift.length-1],
      steps-1
    ),

    // tints (add white)
    // color is in lch format
    tints: (color, steps) => {
      const { r, g, b, alpha, mode } = lch2rgb(color),
            colors = [],
            round = Math.round;

      for (let i = 1; i <= steps; i++) {
        let v = i / steps;
        colors.push({
          r: round(r + (255 - r) * v),
          g: round(g + (255 - g) * v),
          b: round(b + (255 - b) * v),
          alpha,
          mode,
        });
      }
      return colors.map(RGBcolor => rgb2lch(RGBcolor));
    },

    // and shades (add black)
    // color is in lch format
    shades: (color, steps) => {
      const { r, g, b, alpha, mode } = lch2rgb(color),
            colors = [],
            ceil = Math.ceil;

      for (let i = steps; i > 0; i--) {
        let v = i / steps;
        colors.push({
          r: ceil(r * v),
          g: ceil(g * v),
          b: ceil(b * v),
          alpha,
          mode,
        });
      }
      return colors.map(RGBcolor => rgb2lch(RGBcolor));
    },

    // color is in lch format
    lightAndDark: (color) => ([
      tints(color, 3)[1],
      color,
      shades(color, 3)[1]
    ]),

    // and to alpha (add transparent)
    // color is in lch format
    toAlpha: (color, steps) => {
      const { r, g, b, alpha, mode } = lch2rgb(color),
            colors = [],
            ceil = Math.ceil;

      for (let i = steps; i > 0; i--) {
        let v = i / steps;
        colors.push({
          r,
          g,
          b,
          alpha: 1.0 - v,
          mode,
        });
      }
      return colors.map(RGBcolor => rgb2lch(RGBcolor)).reverse();
    },

    // color is in lch format
    monochromatic: (color, steps) => ([
      ...shades(color, Math.floor(steps)).reverse(),
      ...tints(color, Math.ceil(steps)),
    ]),

    // color is in lch format
    tonal: (color, steps) => gradient(color, { ...color, c: 0 }, steps-1),

    // color is in lch format
    // contrast  is a number between 0 and 100
    // hueOffset is a number between -360 and 360
    categorical: (color, contrast = 66, hueOffset = -120, steps) => {
      const { l, c, h, alpha, mode } = color,
            s = steps/2;
      return gradient(
        {
          l: l - (l*(contrast/100)) + s,
          c,
          h,
          alpha,
          mode,
        },
        {
          l: l + s,
          c,
          h: h + hueOffset,
          alpha,
          mode,
        },
        steps-1
      );
    },

    // color is in lch format
    // contrast  is a number between 0 and 100
    sequential: (color, contrast = 80, steps) => ([
      ...gradient(
        { ...color, l: l*(0.8*(contrast/100)) },
        { ...color, c: c-(c/100*90), l: (100-l)+((l/100)*contrast) },
       steps-1
      )
    ]),

    // color1 and color2 are in lch format
    // contrast is a number between 0 and 100
    // middlePoint is a number between 0.0 and 1.0
    divergent: (color1, color2, contrast = 40, middlePoint = 0.5, steps) => {
      let arr = [
        ...gradient(
          { ...color1, l: (l*middlePoint/100*(80-contrast))/middlePoint },
          { ...color2, c: c-(c/100*100) },
          (steps * middlePoint)
        ),
        ...gradient(
          { ...color2, c: c-(c/100*100) },
          { ...color1, h: h+color2.h, l: (120-l)+(l*middlePoint/100*(100-contrast))*middlePoint },
          steps-(steps * middlePoint)
        ),
      ];
      arr.splice(Math.ceil((steps-1)*middlePoint), 1);
      return arr;
    },
  };

  /* NOT USED YET
  function invertHex(hex) {
    return (Number(`0x1${hex}`) ^ 0xFFFFFF).toString(16).substr(1).toUpperCase()
  }
  */

  //
  // begin
  //
  this.mode = base.mode || null;

  // we're done defining funcs, lets run them and create the palettes:
  // generate the palettes, always in LCH mode

  // IMPORTANT - always format input color to LCH
  this.baseColor = base;

  if (base.mode !== 'lch') this.baseColor = this.convert[`${base.mode}2lch`](base);
  const { l, c, h, alpha, mode } = this.baseColor;
  this.baseColor.css = `lch(${l}% ${c} ${h}deg${(alpha || alpha === 0) ? ' / '+alpha : ''})`
  const bc = this.baseColor;

  // the functions that generate our palettes
  const {
    scientific,
    gradient,
    gradients,
    hueShift,
    hueGradient,
    randomised,
    tints,
    shades,
    monochromatic,
    lightAndDark,
    tonal,
    toAlpha,
    categorical,
    sequential,
    divergent,
  } = this.create;

  // add all scientific palletes to `this`
  const scientificPalettes = scientific(bc),
        scientificNames = Object.keys(scientificPalettes);

  scientificNames.forEach(n => this[n] = scientificPalettes[n]);

  // add "equidistant" palette
  this.equidistant = hueShift({ ...bc, h: 180 }, {
    steps,
    minLight: l,
    maxLight: l,
    hueStep: 360/(steps+1),
  }).reverse();

  // add tints and shades palette
  this.tints = tints(bc, steps);
  this.shades = shades(bc, steps).reverse();

  // add monochromatic palette
  this.monochromatic = monochromatic(bc, steps/2)
  this.monochromaticScale = monochromatic(bc, 50);

  // add light and dark palette
  this.lightAndDark = lightAndDark(bc);

  // add tonal palette
  this.tonal = tonal(bc, steps)
  this.tonalScale = tonal(bc, 100);

  // fade to transparent
  this.toAlpha = toAlpha(bc, steps)
  this.toAlphaScale = toAlpha(bc, 100);

  this.randomised = sortBy(
    Array.from({ length: steps }, () => randomised(bc, 100)),
    'l',
    'asc'
  );

  // add hueShift palette
  this.hueShift = hueShift(bc, {
    steps,
    minLight: 30,
    maxLight: 80,
    hueStep: 15,
    ...opts.hueShift,
  }).reverse();

  // define the hue shift pickers/grids
  this.hueShiftTints = transpose(this.hueShift.map(color => tints(color, steps).reverse()));
  this.hueShiftShades = transpose(this.hueShift.map(color => shades(color, steps)));

  // combine them into one, keep every other item, drop the outer rows
  this.picker = [
    ...this.hueShiftTints,
    ...this.hueShiftShades,
  ];
  this.picker.shift();

  // a customisable palette with its own hueShift and max/min lightness options
  this.pixelArt = transpose([
    ...this.hueShift.map(LCHcolor => hueShift(LCHcolor, {
      steps,
      minLight: l,
      maxLight: l,
      hueStep: -22.5, // gives a nice wide spread of hues and shades
      ...opts.hueShift,
      ...opts.pixelArt,
     })),
  ]);

  this.hueGradient = hueGradient(steps);

  this.hueScale = hueGradient(100);

  this.categorical = categorical(bc, 60, 90, steps);

  this.categoricalReverse = categorical(bc, 60, -90, steps);

  this.categoricalComplementary = categorical(bc, 60, 180, steps);

/*
  this.categoricalTriadic = categorical(bc, 60, 120, steps);

  this.categoricalTriadicReverse = categorical(bc, 60, -120, steps);
*/

  this.sequential = sequential(bc, 86, steps);

  this.sequentialScale = sequential(bc, 86, 100);

  this.divergent = divergent(bc, this.sequential[steps-1], 35, 0.5, steps);

  this.divergentScale = divergent(bc, this.sequential[steps-1], 35, 0.5, 100);

  this.list = [
    ...scientificNames,
    'equidistant',
    'tints',
    'shades',
    'monochromatic',
    'monochromaticScale',
    'tonal',
    'tonalScale',
    'toAlpha',
    'toAlphaScale',
    'lightAndDark',
    'randomised',
    'categorical',
    'categoricalReverse',
/*
    'categoricalTriadic',
    'categoricalTriadicReverse',
*/
    'categoricalComplementary',
    'sequential',
    'sequentialScale',
    'divergent',
    'divergentScale',
    'hueGradient',
    'hueScale',
    'hueShift',
    'hueShiftTints',
    'hueShiftShades',
    'picker',
    'pixelArt',
  ];

  // lets be nice - return each palette in the same color mode as the base
  // color we received.. currently all colours are stored in LCH mode

  const converterFn = base.mode !== 'lch' ? this.convert[`lch2${base.mode}`] : null;

  this.convertPalettes = () => {
    if (!converterFn) return;
    this.list.forEach(p => {
      // for each palette, convert to the mode given in the input base color
      this[p] = this[p].map(LCHcolor => {
          return Array.isArray(LCHcolor)
            ? [ ...LCHcolor.map(obj => converterFn(obj)) ]
            : converterFn(LCHcolor);
      });
    });
  }

  this.convertPalettes();

  // return all our palettes in an object
  return this;
}



//
// helper functions to log colours as squares to the dev tools console and to page
//

const logOpts = {
  borders: true,
  rounded: false,
  spacing: false,
  greyscale: false,
};

const logColors = (name, mode, i) => {
  const colors = palettes[name] || name;
  colors.forEach((c, i) => {
    const bg = c.css;
    const baseStyles = [
      "aspect-ratio: 1/1",
      `background-color: ${bg}`,
      "display: inline-block",
      "height: 28px",
    ].join(';');
    // console log if not a wheel or scale
    if (!(/wheel|picker|scale|Scale/.test(name))) {
      console.log(`%c  `, baseStyles, `${name}[${i}]   ${bg}`);
    }
  });
  if (!(/wheel|picker|scale|Scale/.test(name))) {
    console.log('-------------------');
  }
}

const drawColors = (name, mode, i) => {
  const colors = palettes[name] || name,
        el = document.createElement('div');
  // only show header for first row, if palette is a grid (has rows and columns)
  if (name.startsWith('picker') && i === 0) el.innerHTML = `<h3>${name}</h3>`;
  if (name.toLowerCase().indexOf('scale') !== -1) el.innerHTML = `<h3>${name}</h3>`;
  // else just print header once for whole palette
  if (!/^picker|^scale|Scale/.test(name)) el.innerHTML = `<h3>${name}</h3>`;
  // draw colors
  let baseStyles;
  colors.forEach((c, i) => {
    const bg = c.css;
    // if showing "wheel" palette, or any scale, do 1px width, no inner borders,
    // cos these palettes are large - have lots of items in them
    if (/wheel|Scale|scale/.test(name)) {
      baseStyles = [
        `background-color: ${bg}`,
        `border: 0px !important`,
        `border-radius: 0px !important`,
        "display: inline-block",
        `margin-left: 0; margin-right: 0; margin-top: -1px`,
        "height: 28px",
        `width: 2.45px`,
      ];
      if (/wheel/.test(name)) {
        baseStyles = [
          ...baseStyles,
          `width: 0.675px`,
        ];
      }
    // else if showing a regular (smaller) palette, show boxes of colours
    } else {
      baseStyles = [
        "aspect-ratio: 1/1",
        `background-color: ${bg}`,
        "display: inline-block",
        "height: 28px",
      ];
    }
    baseStyles = baseStyles.join(';');
    // now draw the colour(s) to the page
    el.classList.add('palette');
    el.innerHTML += `<div class="color${logOpts.borders ? " with-borders" : ''}${logOpts.rounded ? "with-rounded" : ''}" style="${baseStyles}"></div>`;
    // If showing a color mix, show as sum, like so: color1 + color2 = color3
    if (/mix|Mix/.test(name)) {
      const sum = symbol => `<span style="position: relative; top: -8px; display: inline-block;">&nbsp${symbol}&nbsp;</span>`;
      if (i  <  colors.length - 2) el.innerHTML += sum('+');
      if (i === colors.length - 2) el.innerHTML += sum('=');
    }
  });
  document.body.append(el);
}




// All palettes are returned in the same color mode you passed in:
//console.log('palettes', palettes);



function render (palettes) {
  //
  //
  // palette conversion utils
  //
  //

  // get some color space conversion functions
  const {
    lab2lch,
    lch2lab,
    lch2rgb,
    rgb2cmyk,
    rgb2gl,
    rgb2hex,
    rgb2hsl,
    rgb2hsv,
    rgb2hwb,
    rgb2lab,
    rgb2lch,
    rgb2xyz,
    xyz2lab,
  } = palettes.convert;


  // examples of converting a palette to a different color mode
  /*
  console.log('-------------------');
  console.log('conversions:');
  console.log('primary (CMYK)', palettes.primary.map(color => rgb2cmyk(lch2rgb(color))));
  console.log('primary (HEX)',  palettes.primary.map(color => rgb2hex(lch2rgb(color))));
  console.log('primary (HSL)',  palettes.primary.map(color => rgb2hsl(lch2rgb(color))));
  console.log('primary (HSV)',  palettes.primary.map(color => rgb2hsv(lch2rgb(color))));
  console.log('primary (HWB)',  palettes.primary.map(color => rgb2hwb(lch2rgb(color))));
  console.log('primary (XYZ)',  palettes.primary.map(color => rgb2xyz(lch2rgb(color))));
  console.log('primary (LAB)',  palettes.primary.map(color => xyz2lab(rgb2xyz(lch2rgb(color)))));
  console.log('-------------------');
  */

  //
  //
  // other palette utils
  //
  //

  const {
    spin,      // spin(color, degrees)                  spin a colour by given degrees
    mix,       // mix(color1, color2, 0.5)              mix 2 colors by given amount
    rescale,   // scale(num, start1,end1, start2,end2)  rescale a number to a new scale
    sortBy,    // sortBy(palette, key[, 'asc'])         sort a palette by the given key
    transpose, // transpose(array)                      flip the rows and columns of a 2d array
  } = palettes.utils;

  // utils - mixing colours   (color1, color2, mixAmount)
  const mixed20 = mix(lchColor, palettes.hueGradient[8], 0.20);
  const mixed50 = mix(lchColor, palettes.hueGradient[8], 0.50);
  const mixed80 = mix(lchColor, palettes.hueGradient[8], 0.80);

  // show the color mixes as a palette (color1 + color2 = color3)
  palettes['mixedColor (20%)'] = [
    lchColor,                 // first color to mix (use the base color, in LCH format)
    palettes.hueGradient[8],  // second color to mix
    mixed20
  ];
  // show the color mixes
  palettes['mixedColor (50%)'] = [
    lchColor,                 // first color to mix (use the base color, in LCH format)
    palettes.hueGradient[8],  // second color to mix
    mixed50
  ];
  palettes['mixedColor (80%)'] = [
    lchColor,                   // first color to mix (use the base color, in LCH format)
    palettes.hueGradient[8],    // second color to mix
    mixed80
  ];
  palettes.list.push('mixedColor (20%)');
  palettes.list.push('mixedColor (50%)');
  palettes.list.push('mixedColor (80%)');



  //
  // lets grab the functions needed to draw our own custom palettes
  //

/*
  const {
      scientific,
      hueShift,
      gradient,
      gradients,
      hueGradient,
      randomised,
      tints,
      shades,
      monochromatic,
      lightAndDark,
      tonal,
      toAlpha,
      // data viz palettes
      categorical,
      sequential,
      divergent,
  } = palettes.create;


  // ...and lets add a bunch of our own palettes to the `palettes` object

  // generate a multi-color gradient palette
  const colors = [
    { ...lchColor, h: lchColor.h, l: 70  },
    { ...lchColor, h: lchColor.h + 240,  l: 45  },
    { ...lchColor, h: lchColor.h + 90,  l: 75  },
    { ...lchColor, h: lchColor.h + 320, l: 40  },
  ];

  palettes[`fourColorScale (60, 20, 20)`] = gradients(colors, [ 60, 20, 20 ]);
  palettes.list.push(`fourColorScale (60, 20, 20)`);

  palettes[`fourColorScale (20, 60, 20)`] = gradients(colors, [ 20, 60, 20 ]);
  palettes.list.push(`fourColorScale (20, 60, 20)`);

  palettes[`fourColorScale (20, 20, 60)`] = gradients(colors, [ 20, 20, 60 ]);
  palettes.list.push(`fourColorScale (20, 20, 60)`);

  palettes[`fourColorScale (33, 33, 33)`] = gradients(colors, [ 33, 33, 33 ]);
  palettes.list.push(`fourColorScale (33, 33, 33)`);




  // generate a bunch of sequential palettes
  for (let i = 1; i <= 8; i ++) {
    const color1 = { ...lchColor, h: lchColor.h + 45*i };
    palettes[`sequential${i}`] = sequential(color1, 90, steps);
    palettes.list.push(`sequential${i}`);
  }

  // generate a bunch of categorical palettes
  for (let i = 1; i <= 8; i ++) {
    const color1 = { ...lchColor, h: lchColor.h + 45*i };
    palettes[`categorical${i}`] = categorical(color1, 50, -90, steps);
    palettes.list.push(`categorical${i}`);
  }

  // generate a bunch of "divergent" palettes
  for (let i = 1; i <= 8; i ++) {
    const color1 = { ...lchColor, h: lchColor.h + 33*i };
    const color2 = { ...lchColor, h: (lchColor.h + 180) + 33*i, l: 95.5 };
    palettes[`divergent${i}`] = divergent(color1, color2, 40, 0.5, steps);
    palettes.list.push(`divergent${i}`);
    // generate a bunch of "divergent" scales
    palettes[`divergentScale${i}`] = divergent(color1, color2, 40, 0.5, 100);
    palettes.list.push(`divergentScale${i}`);
  }
*/

  // Palette converts its output to the same color space as the base color
  // it received, but we've just added more palettes to it, so lets convert
  // the new ones as well, so *all* palettes are in the same color mode as
  // the base color that Palette received.
  palettes.convertPalettes();


  // CSS4 is prob not supported in browsers yet, so:
  //
  // If needed, convert the palettes from LCH to RGB so we can display them
  // on all browsers - even those that don't yet support CSS 4 (which supports
  // the `lch()` color space).

  if (baseColor.mode === 'lch') {
    palettes.base = palettes.baseColor;
    palettes.list.forEach(name => {
      palettes[name] = palettes[name].map((color, row) => {
        if (Array.isArray(color)) {
          return palettes[name][row].map(c => lch2rgb(c));
        } else {
          return lch2rgb(color);
        }
      });
    });
  }


  //
  //
  // now show the colors
  //
  //


  palettes.base = [lch2rgb(palettes.baseColor)];
  // show the base color
  drawColors('base', 'lch');
  logColors('base', 'lch');

  // update color chooser UI box
  document.querySelector('.color-chooser').style.border = `1px solid ${palettes.base[0].css}`;
  document.querySelector('.color-chooser').style.borderLeft = `110px solid ${palettes.base[0].css}`;

  // draw palettes to page
  palettes.list.forEach(p => {
    if (Array.isArray(palettes[p][0])) {
      // loop over rows, then print the palettes
      palettes[p].forEach((swatch, i) => { // for each row (palette)
        const name = `picker ${p}`; // choose a "picker" name
        palettes[name] = swatch;    // create a tmp palette for drawColors
        drawColors(name, 'lch', i); // draw it
        delete palettes[name];      // get rid of it
      });
    } else {
      // print the palettes
      drawColors(p, 'lch'); // draw to page
      //logColors(p, 'rgb');  // log in dev tools, will print CSS values
    }
  });
}


// ======================================================================== //
//
//
// Usage:
//
//
// Define colors as objects, with a mode, alpha value and props for
// the given mode.

const lchColor = {
  l: 75,    // 0 to 100, or 0% to 100%
  c: 100,   // 0 to 150, or 0% to 100%, or 'none'
  h: 30,    // 0 to 360, or 0deg to 360deg
  alpha: 1, // 0 to 1
  mode: "lch"
};
const rgbColor = {
  r: 255,   // 0 to 255
  g: 74,    // 0 to 255
  b: 83,    // 0 to 255
  alpha: 1, // 0 to 1
  mode: "rgb"
};
const baseColor = lchColor;

// update the UI
inputs.l.value = Number(lchColor.l);
inputs.c.value = Number(lchColor.c);
inputs.h.value = Number(lchColor.h);
inputs.a.value = Number(lchColor.alpha);

// Set some palette options.
const steps = 9;
const opts = {
  hueShift: { hueStep:  12,   minLight: 15, maxLight: 100 },
  pixelArt: { hueStep: -22.5, minLight: 10, maxLight: 95, steps: 10 },
};


// Generate all palettes, from a single RGB or LCH (preferred) color
palettes = new Palette(baseColor, steps, opts);

// finally, run the render function
render(palettes);

</script>
</body>
</html>
